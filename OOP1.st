Object subclass: #Monom	instanceVariableNames: 'exp coef'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Monom methodsFor: 'accessing' stamp: 'initalize 3/29/2017 18:10'!coef	"getter of the field coef"	^coef.! !!Monom methodsFor: 'accessing' stamp: 'initalize 3/29/2017 18:37'!coef: anInteger	"The method is a setter of coef field. the method will throw error 'invalid input' anInteger is not an integer "	(anInteger isInteger) ifTrue:[coef:=anInteger] ifFalse:[self error: 'invalid input'].! !!Monom methodsFor: 'accessing' stamp: 'initalize 3/29/2017 18:05'!exp	"getter method of exp"	^exp.! !!Monom methodsFor: 'accessing' stamp: 'initalize 3/29/2017 18:26'!exp: anInteger	"a setter method of exp. the method will throw 'invalid input' error if the anInteger is not integer or the value is 	negative"	|isValidInput|	isValidInput:=(anInteger isInteger) and: [anInteger>=0]. "boolean contition with short-circuit"	isValidInput ifTrue:[exp:=anInteger] ifFalse:[self error: 'invalid input' ].! !!Monom methodsFor: 'initialize-release' stamp: 'initalize 3/29/2017 18:04'!initialize	coef:=0.	exp:=0.! !Object subclass: #Polynom	instanceVariableNames: 'monoms'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP1'!!Polynom methodsFor: 'adding' stamp: 'initalize 4/1/2017 11:19'!add: aPolynom	"The method will return a newPolynom of the sum between self and aPolynom. aPolynom must be Polynom instance, otherwise throwing an error of 'invalid input'"	| newPolynom  |		newPolynom:= Polynom new.		"now we need to building the newPolynom by adding all monoms in self and aPolynom"		aPolynom addAllMonomsTo: newPolynom. "we add the first aPolynom to the newPolynom so that if aPolynom is not an instance of Polynom an error will be thrown."		^ self addAllMonomsTo: newPolynom. "we returning the newPolynom after adding all monoms to it."				! !!Polynom methodsFor: 'adding' stamp: 'initalize 4/1/2017 11:24'!addMonom: aMonom	"the method will copy aMonom and add it to the polynom (mutuable).	if aMonom is not a Monom object than an error 	will be thrown as 'invalid method' "	| monomKey monomValue |	self actionOnMonom: aMonom Do:[			"if it has coef of 0 then we are done,no monom need to be added"			(aMonom coef = 0) ifTrue:[^self].			"we need to copy the values before adding them to the collection"			monomKey:=aMonom exp.			monomValue:=aMonom coef.			"Also we need to check if the exp is already exist, if so we need to take him and edit his coef"			monoms at:(monomKey)				 ifPresent:[					monomValue:=monomValue+monoms at: monomKey. "adding the coef"					monoms at: monomKey put:monomValue. "updating the value"					] ifAbsent:[					"no such exp(key) exist then we can add it to the collection"					 monoms add:monomKey->monomValue					]		] .! !!Polynom methodsFor: 'accessing' stamp: 'initalize 3/29/2017 20:07'!asDictonary	"the collection is already a Dictonary, so this is just a get method"	^monoms.! !!Polynom methodsFor: 'accessing' stamp: 'initalize 4/1/2017 11:29'!iterator	"The method return a block of the current state of the polynom.the block will allow to iterate over the collection in 	desc order of the exp value,"|orderedMonoms|"add them to the sorted Collection"orderedMonoms:=self getSortedMonoms."after we have the sorted collection we retun a block which return the next element, respectivly. if no element exist a nil block is returened"^[ |monom| (orderedMonoms isEmpty) 	ifTrue:[nil]	ifFalse:[		monom:= Monom new.		monom exp: (orderedMonoms first) exp.		monom coef: (orderedMonoms first) coef.		orderedMonoms removeFirst.		^monom		] "end of false block"	]. "end of retured block"! !!Polynom methodsFor: 'calculations' stamp: 'initalize 4/1/2017 10:12'!eval: anInteger	"the method will evaluate the polynom in a certin point (anInteger)"	| sum |	"need to loop over the each key in the monoms and calculate the sum of aValue*(aPoint raisedTo akey)"	sum:=0.	monoms keysAndValuesDo: [:aKey :aValue |   sum:=sum+aValue*(anInteger raisedTo: aKey)].	^sum.! !!Polynom methodsFor: 'calculations' stamp: 'initalize 3/31/2017 11:20'!multiplyByMonom: aMonom	"The method change the reciver and multiply the polynom by the monom. if aMonom is not a Monom error will be 	thrown error:'invalid input'"	| monomCoef monomExp newMonoms|	self actionOnMonom:aMonom Do:[		newMonoms:=Dictionary new.		monomCoef:=aMonom coef.		monomExp:=aMonom exp.		monoms keysAndValuesDo: [:expKey :coefValue 									| newMonoms  add: (monomExp+expKey)->(monomCoef+coefValue) ].		"updating the collection to the new dictionary"		monoms:=newMonoms.											].	 ! !!Polynom methodsFor: 'printing' stamp: 'initalize 3/31/2017 18:44'!printOn:aStream|orderdMonomC additionFlag str |additionFlag :=0.orderdMonomC := self getSortedMonoms.str :='P(x) = '.(orderdMonomC isEmpty)	ifTrue:[		str:= (str,'0').		]	ifFalse:[		"iterate each monom (m) and concate it to the str"		(orderdMonomC) do: [:m | 									(additionFlag = 0)ifTrue:[additionFlag :=1]ifFalse:[str:= (str,' + ')]. "add a plus sign on every iteration except the first one"									((m coef) < 0)ifTrue:[str:= (str,'(',m coef asString,')')] ifFalse:[str:= (str,m coef asString)]. "concating the coef number"									str:= (str,'x',(m exp) asString). "concating the x & exp"		]. "ending do block"	]. "ending false block"aStream nextPutAll: str.! !!Polynom methodsFor: 'private' stamp: 'initalize 3/31/2017 11:17'!actionOnMonom: aMonom Do:aBlock	"the metod activate the block if aMonom is Monom object otherwise throwing an exception"	(aMonom isKindOf: Monom) ifTrue:[aBlock value.] ifFalse: [self error:'invalid input'].! !!Polynom methodsFor: 'private' stamp: 'initalize 4/1/2017 11:19'!addAllMonomsTo:newPolynom	"The method will add each monom in this(self) Polynom to the newPolynom using the addMonom method. The method will return the newPolynom"	|iter monom|	(newPolynom isKindOf: Polynom) ifTrue:		[		iter:= self iterator.		(monom:=(iter value) isNil) whileFalse:[ newPolynom addMonom: monom].		] ifFalse:[self error: 'invalid input'].	^newPolynom.! !!Polynom methodsFor: 'private' stamp: 'initalize 4/1/2017 11:09'!copyPolynomTo:newPolynom	"The method will add each monom in this(self) Polynom to the newPolynom using the addMonom method. The method will return the newPolynom"	|iter monom|	(newPolynom isKindOf: Polynom) ifTrue:		[		iter:= self iterator.		(monom:=(iter value) isNil) whileFalse:[ newPolynom addMonom: monom].		] ifFalse:[self error: 'invalid input'].	^newPolynom.! !!Polynom methodsFor: 'private' stamp: 'initalize 4/1/2017 11:44'!getSortedMonoms"The method return the monoms collection as sortedCollection sorted by exp desc ordered."|sortedCollection|sortedCollection :=SortedCollection sortBlock: [:a :b | a exp>b exp]."iterate over the dictionary and convert it to sortedCollection"(monoms) keysAndValuesDo: [:ex :co| |monom| monom:=(Monom new) exp: ex; coef: co. sortedCollection add: monom].^sortedCollection.! !!Polynom methodsFor: 'initialize-release' stamp: 'initalize 3/31/2017 13:41'!initialize	"the method will initalize the collection to a Dictionary[key=exp,value=coef]"	monoms:=Dictionary new.! !